// Comments
/* Multiline */

let a = 5;		// Semicolons are optional
// or
let a:int = 5	// Explicit type
// or
let a:int		// Without value (default)

// Types ar NOT dynamic (but inferenced)

// If
if a > 5 =>
  // Blocks using identation
  doSomething()

// If else
if 1 == 1 then
  // ...
else
  // ...

// Switch
let a = 25
match a =>
  when 13 =>
    print "a is 13"
  ...
  otherwise =>
    print "Can't say what a is"

// For
for (i = 0, i<5, i++) =>
  // Something

// For in (foreach)
for item in list =>
  // Something

// Functions explicit return type is optional
let f1 (a, b, c) =>
  return a + b + c

// Without arguments
let f2 =>
  print("Hello")

// Lambda-expressions
let f3 (a, b, c) => a + b + c
let f4 => a + b + c

// Some "magic" things
let c = (a, b)		// a tuple

let a, b = 1, 2		// Multivalue
let a = 1, b = 2

a, b = b, a			// Var switch

// List
let list1 = (1, 2, 3, 4)

// Array
let array1 = [1, 2, 3, 4]
// Arrays are immutable lists

// Tuple
let tuple1 = {1, 2, 3, 4}
// Tuples are immutable lists with named values

let listOrArrayLength = #listOrArray	// Length of list or array

a, b = b, a // Swap
// or
swap a, b

// Tuple, array, list unpack
let a, b <- {1, 2}
let a <- (1, 2, 3, 4)

// Sequentional function call
let sum (a, b) => a + b
let mod (a, b) => a * b

sum 2, 3 
  -> mod 5 
  -> sum 3
// (2 + 3) * 5 + 3

// Data struct
data SomeData(
	  a:int, 
	  b:string, 
	  c:float
  ):

  // Before data inserting
  over before:
	print @a				// @ - access to current context (this), Error: data wasn't inserted yet
  over after:
    print @a				// OK
	// After data inserting

data SomeOtherDataStruct(g:int, h:int, j:int)
data SomeOtherDataStruct2(d:int, e:int, f:int)
  include SomeOtherDataStruct2		// Not inheritanse, but composition

// Using leafs

let leaf1 = SomeLeaf(1, '2', 3.123)
// data leaf
let leaf2 = leaf1 >>> SomeOtherDataLeaf(1, 2, 3) // leaf2 now has a, b, c, d, e, f
// let leaf3 = leaf2 >>> leaf1 // Error: repeating data members
let leaf3 = leaf1 * 2		// Math operations like in vectors

// Literals
"231" // or '213' - string
23 // - int
1.234 // - float
"${12 + 3} = 15" // - string interpolation

// All statements are return values, so they are expressions
let a = if 5 > 1 then 

let a = [for i in [1..5] -> i * 2]	// [2, 4, 6, 8, 10]

// Functional programming elements
// Map, reduce and filter functions
let b = filter (1..10), (i) => i % 2 == 0		// (2, 4, 6, 8)
		-> map (i) => i * 2						// (4, 8, 16, 24)
		-> reduce (x, xs) => x + xs		// 52, or -> sum
// also works for arrays

// ! means immutable
!let a = 5

a = 10		// Error: a is immutable